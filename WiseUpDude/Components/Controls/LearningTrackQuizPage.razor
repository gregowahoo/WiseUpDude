@using WiseUpDude.Model
@using Microsoft.AspNetCore.Components.Forms // Required for EditForm, InputText, InputTextArea
@inject WiseUpDude.Data.Repositories.Interfaces.ILearningTrackQuizRepository QuizRepo
@inject WiseUpDude.Shared.Services.ToastService ToastService

@rendermode InteractiveServer

<div class="d-flex justify-content-between align-items-center mb-3">
    <h4 class="text-secondary mb-0"><i class="bi bi-patch-question me-2"></i>Quizzes for Source ID: @LearningTrackSourceId</h4>
    <button class="btn btn-success" @onclick="ShowAddModal">
        <i class="bi bi-plus-circle-fill me-1"></i> Add New Quiz
    </button>
</div>

@if (quizzes == null && !initialLoadComplete) // Show loading indicator only on initial load
{
    <div class="d-flex justify-content-center align-items-center" style="min-height: 150px;">
        <div class="spinner-border text-success" role="status"><span class="visually-hidden">Loading...</span></div>
        <strong class="ms-2">Loading quizzes...</strong>
    </div>
}
else if (quizzes == null || !quizzes.Any()) // Handle null or empty after load attempt
{
     <div class="alert alert-light text-center" role="alert">
        <i class="bi bi-info-circle me-2"></i> No quizzes found for this source.
        <button class="btn btn-link p-0 ms-1" @onclick="ShowAddModal">Add one now!</button>
    </div>
}
else
{
    <div class="list-group">
        @foreach (var quiz in quizzes)
        {
            <div class="list-group-item list-group-item-action @(selectedQuiz?.Id == quiz.Id ? "active" : "")" @key="quiz.Id">
                <div class="d-flex justify-content-between align-items-start">
                    <div class="flex-grow-1 me-3" @onclick="() => HandleQuizSelection(quiz)" style="cursor:pointer;">
                        <div class="d-flex w-100 justify-content-between">
                            <h5 class="mb-1 @(selectedQuiz?.Id == quiz.Id ? "text-white" : "")">
                                <i class="bi bi-type me-1"></i>@quiz.Name
                            </h5>
                            <small class="@(selectedQuiz?.Id == quiz.Id ? "text-white-50" : "text-muted")">
                                <i class="bi bi-calendar-event me-1"></i>Created: @quiz.CreationDate.ToString("yyyy-MM-dd HH:mm")
                            </small>
                        </div>
                        <p class="mb-1 @(selectedQuiz?.Id == quiz.Id ? "text-white-75" : "")">
                            <i class="bi bi-text-paragraph me-1"></i>@quiz.Description
                        </p>
                    </div>
                    <div class="ms-2 text-nowrap">
                        <button class="btn btn-sm @(selectedQuiz?.Id == quiz.Id ? "btn-light" : "btn-primary") me-1" @onclick="() => HandleQuizSelection(quiz)" @onclick:stopPropagation="true" title="Select Quiz">
                            <i class="bi bi-check-circle-fill"></i> Select
                        </button>
                        <button class="btn btn-sm @(selectedQuiz?.Id == quiz.Id ? "btn-outline-light" : "btn-outline-secondary") me-1" @onclick="() => ShowEditModal(quiz)" @onclick:stopPropagation="true" title="Edit Quiz">
                            <i class="bi bi-pencil-square"></i> Edit
                        </button>
                        <button class="btn btn-sm @(selectedQuiz?.Id == quiz.Id ? "btn-outline-light" : "btn-outline-danger")" @onclick="() => DeleteQuiz(quiz)" @onclick:stopPropagation="true" title="Delete Quiz">
                            <i class="bi bi-trash"></i> Delete
                        </button>
                    </div>
                </div>
            </div>
        }
    </div>
    // Simple pagination example (if needed, can be expanded)
    // For a more robust pagination, you'd need to implement skipping and taking in LoadQuizzes
    // and manage current page, items per page, etc.
    // This example assumes all quizzes are loaded and displayed.
    // If you have many quizzes, proper server-side pagination with the list approach
    // would involve more state management (currentPage, pageSize) and modifying LoadQuizzes
    // to fetch only the current page's data.
}

<Modal IsVisible="@showModal" Title="@modalTitle" OnClose="CloseModal">
    <EditForm Model="@modalQuiz" OnValidSubmit="SaveQuiz">
        <DataAnnotationsValidator />
        <ValidationSummary />
        <div class="mb-3">
            <label class="form-label">Name</label>
            <InputText class="form-control" @bind-Value="modalQuiz.Name" />
            <ValidationMessage For="@(() => modalQuiz.Name)" />
        </div>
        <div class="mb-3">
            <label class="form-label">Description</label>
            <InputTextArea class="form-control" @bind-Value="modalQuiz.Description" />
            <ValidationMessage For="@(() => modalQuiz.Description)" />
        </div>
        <div class="d-flex justify-content-end mt-3">
            <button type="button" class="btn btn-secondary me-2" @onclick="CloseModal">Cancel</button>
            <button type="submit" class="btn btn-primary">
                <i class="bi bi-save me-1"></i> @(isEdit ? "Update" : "Save")
            </button>
        </div>
    </EditForm>
</Modal>

@code {
    [Parameter] public int LearningTrackSourceId { get; set; }
    [Parameter] public EventCallback<LearningTrackQuiz?> OnLearningTrackQuizSelected { get; set; } // Nullable if deselecting
    [Parameter] public int LearningTrackCategoryId { get; set; } // Used? If not, can be removed.

    private List<LearningTrackQuiz>? quizzes;
    private LearningTrackQuiz? selectedQuiz;
    private bool initialLoadComplete = false;

    private bool showModal = false;
    private string modalTitle = "Add/Edit Quiz";
    private LearningTrackQuiz modalQuiz = new();
    private bool isEdit = false;

    protected override async Task OnParametersSetAsync()
    {
        if (LearningTrackSourceId > 0) // Ensure ID is set before loading
        {
            selectedQuiz = null; // Reset selection when source changes
            await LoadQuizzes();
        }
        else
        {
            quizzes = new List<LearningTrackQuiz>(); // Clear if no valid ID
            initialLoadComplete = true;
        }
    }

    private async Task LoadQuizzes()
    {
        if (!initialLoadComplete) // Set quizzes to null only if it's the initial load phase for this parameter set
        {
            quizzes = null;
            await InvokeAsync(StateHasChanged); // Show loading spinner
        }

        try
        {
            var allQuizzes = await QuizRepo.GetAllQuizzesAsync(); // Assuming this repo method is factory-enabled
            quizzes = allQuizzes.Where(q => q.LearningTrackSourceId == LearningTrackSourceId)
                                .OrderByDescending(q => q.CreationDate) // Example sorting
                                .ToList();
        }
        catch (Exception ex)
        {
            await ToastService.ShowToast($"Failed to load quizzes: {ex.Message}", ToastLevel.Error);
            quizzes = new List<LearningTrackQuiz>(); // Ensure quizzes is not null after an error
        }
        finally
        {
            initialLoadComplete = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleQuizSelection(LearningTrackQuiz quiz)
    {
        if (selectedQuiz?.Id == quiz.Id)
        {
            // Optional: Deselect if clicking the same item again
            // selectedQuiz = null;
            // await OnLearningTrackQuizSelected.InvokeAsync(null);
        }
        else
        {
            selectedQuiz = quiz;
            await OnLearningTrackQuizSelected.InvokeAsync(selectedQuiz);
        }
        // StateHasChanged(); // Usually not needed if only parent component reacts to selection
    }

    private void ShowAddModal()
    {
        modalTitle = "Add New Quiz";
        modalQuiz = new LearningTrackQuiz { LearningTrackSourceId = LearningTrackSourceId, CreationDate = DateTime.UtcNow };
        isEdit = false;
        showModal = true;
    }

    private void ShowEditModal(LearningTrackQuiz quiz)
    {
        modalTitle = "Edit Quiz";
        // Create a new instance for editing to avoid modifying the list item directly before saving
        modalQuiz = new LearningTrackQuiz
        {
            Id = quiz.Id,
            Name = quiz.Name,
            Description = quiz.Description,
            LearningTrackSourceId = quiz.LearningTrackSourceId,
            CreationDate = quiz.CreationDate
        };
        isEdit = true;
        showModal = true;
    }

    private async Task SaveQuiz()
    {
        // Basic validation example (consider FluentValidation for more complex scenarios)
        if (string.IsNullOrWhiteSpace(modalQuiz.Name))
        {
            await ToastService.ShowToast("Quiz name cannot be empty.", ToastLevel.Warning);
            return;
        }

        try
        {
            // modalQuiz.LearningTrackSourceId is already set in ShowAddModal/ShowEditModal
            if (isEdit)
            {
                await QuizRepo.UpdateQuizAsync(modalQuiz);
                await ToastService.ShowToast("Quiz updated successfully!", ToastLevel.Success);
            }
            else
            {
                modalQuiz.CreationDate = DateTime.UtcNow; // Ensure creation date is set for new quizzes
                await QuizRepo.AddQuizAsync(modalQuiz);
                await ToastService.ShowToast("Quiz added successfully!", ToastLevel.Success);
            }
            showModal = false;
            initialLoadComplete = false; // Trigger reload with spinner
            await LoadQuizzes(); // Refresh the list
        }
        catch (Exception ex)
        {
            await ToastService.ShowToast($"Failed to save quiz: {ex.Message}", ToastLevel.Error);
        }
    }

    private void CloseModal()
    {
        showModal = false;
        modalQuiz = new(); // Clear the modal form
    }

    private async Task DeleteQuiz(LearningTrackQuiz quiz)
    {
        // Optional: Add a confirmation step here using a confirmation modal or JS confirm
        // For simplicity, direct delete is implemented.

        try
        {
            await QuizRepo.DeleteQuizAsync(quiz.Id);
            await ToastService.ShowToast($"Quiz '{quiz.Name}' deleted successfully.", ToastLevel.Success);
            if (selectedQuiz?.Id == quiz.Id) // If the deleted quiz was selected
            {
                selectedQuiz = null;
                await OnLearningTrackQuizSelected.InvokeAsync(null);
            }
            initialLoadComplete = false; // Trigger reload with spinner
            await LoadQuizzes(); // Refresh the list
        }
        catch (Exception ex)
        {
            await ToastService.ShowToast($"Failed to delete quiz: {ex.Message}", ToastLevel.Error);
        }
    }
}