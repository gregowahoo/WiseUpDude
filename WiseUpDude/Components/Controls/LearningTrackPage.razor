@using WiseUpDude.Model
@using Microsoft.AspNetCore.Components.Authorization
@inject WiseUpDude.Data.Repositories.Interfaces.ILearningTrackRepository LearningTrackRepo
@inject WiseUpDude.Shared.Services.ToastService ToastService
@inject AuthenticationStateProvider AuthenticationStateProvider

@rendermode InteractiveServer

<div class="d-flex justify-content-between align-items-center mb-3">
    <h4 class="text-secondary mb-0"><i class="bi bi-list-task me-2"></i>Learning Tracks</h4>
    <button class="btn btn-success" @onclick="AddNewTrack">
        <i class="bi bi-plus-circle-fill me-1"></i> Add New Track
    </button>
</div>

@if (tracks == null)
{
    <div class="d-flex justify-content-center align-items-center" style="min-height: 200px;">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <strong class="ms-2">Loading tracks...</strong>
    </div>
}
else if (!tracks.Any())
{
    <div class="alert alert-light text-center" role="alert">
        <i class="bi bi-info-circle me-2"></i> No learning tracks found.
        <button class="btn btn-link p-0 ms-1" @onclick="AddNewTrack">Add one now!</button>
    </div>
}
else
{
    <div class="card shadow border-0 mb-4 grid-background">
        <div class="list-group list-group-flush">
            @foreach (var track in tracks)
            {
                <div class="list-group-item list-group-item-action @(track == selectedTrack ? "active" : "")" @onclick="() => SelectTrack(track)" style="cursor:pointer;">
                    <div class="d-flex w-100 justify-content-between align-items-start">
                        <div>
                            <h5 class="mb-1 @(track == selectedTrack ? "text-white" : "")">
                                <i class="bi bi-type me-1"></i> @track.Name
                            </h5>
                            @if (!string.IsNullOrWhiteSpace(track.Description))
                            {
                                <p class="mb-1 small @(track == selectedTrack ? "text-white-75" : "text-muted")">
                                    <i class="bi bi-text-paragraph me-1"></i> @track.Description
                                </p>
                            }
                        </div>
                        <div class="action-buttons-list ms-2">
                            <button class="btn btn-sm @(track == selectedTrack ? "btn-light" : "btn-outline-secondary") me-1 mb-1 mb-md-0"
                                    @onclick:stopPropagation="true" @onclick="() => EditTrack(track)" title="Edit Track">
                                <i class="bi bi-pencil-square"></i> <span class="d-none d-md-inline">Edit</span>
                            </button>
                            <button class="btn btn-sm @(track == selectedTrack ? "btn-warning" : "btn-outline-danger")"
                                    @onclick:stopPropagation="true" @onclick="() => DeleteTrack(track)" title="Delete Track">
                                <i class="bi bi-trash"></i> <span class="d-none d-md-inline">Delete</span>
                            </button>
                        </div>
                    </div>
                </div>
            }
        </div>
        @* Removed Paginator for simplicity with list view. Can be re-added with custom list pagination if needed. *@
    </div>
}

<Modal IsVisible="@showModal" Title="@modalTitle" OnClose="CloseModal">
    <EditForm Model="@modalTrack" OnValidSubmit="SaveTrack">
        <div class="mb-3">
            <label class="form-label">Name</label>
            <InputText class="form-control" @bind-Value="modalTrack.Name" />
        </div>
        <div class="mb-3">
            <label class="form-label">Description</label>
            <InputTextArea class="form-control" @bind-Value="modalTrack.Description" />
        </div>
        <button type="submit" class="btn btn-primary">Save</button>
        <button type="button" class="btn btn-secondary ms-2" @onclick="CloseModal">Cancel</button>
    </EditForm>
</Modal>

@code {
    private List<LearningTrack>? tracks;
    // tracksQueryable might not be strictly necessary anymore if not using QuickGrid's IQueryable binding features,
    // but LoadTracksFromRepo populates `tracks` which is then used.
    // private IQueryable<LearningTrack>? tracksQueryable;
    // private PaginationState paginationState = new PaginationState { ItemsPerPage = 10 }; // Removed as QuickGrid Paginator is removed

    private bool showModal = false;
    private string modalTitle = "Add/Edit Track";
    private LearningTrack modalTrack = new();

    private LearningTrack? selectedTrack;

    [Parameter] public EventCallback<LearningTrack> OnLearningTrackSelected { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await LoadTracksFromRepo();
    }

    private async Task LoadTracksFromRepo()
    {
        try
        {
            var result = await LearningTrackRepo.GetAllAsync();
            tracks = result.ToList();
            // tracksQueryable = tracks.AsQueryable(); // Keep if other parts rely on it, otherwise can be removed
        }
        catch (Exception ex)
        {
            await ToastService.ShowToast($"Failed to load tracks: {ex.Message}", ToastLevel.Error);
            tracks = new List<LearningTrack>();
            // tracksQueryable = tracks.AsQueryable(); // Keep if other parts rely on it, otherwise can be removed
        }
    }

    private async Task SelectTrack(LearningTrack track)
    {
        selectedTrack = track;
        StateHasChanged();

        await OnLearningTrackSelected.InvokeAsync(track);
    }

    private async void AddNewTrack()
    {
        modalTitle = "Add New Track";
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var userId = authState.User?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
        modalTrack = new LearningTrack();
        if (!string.IsNullOrEmpty(userId))
        {
            modalTrack.UserId = userId;
        }
        showModal = true;
    }

    private void EditTrack(LearningTrack track)
    {
        modalTitle = "Edit Track";
        modalTrack = new LearningTrack
        {
            Id = track.Id,
            Name = track.Name,
            Description = track.Description,
            CreationDate = track.CreationDate,
            UserId = track.UserId // Ensure UserId is preserved
        };
        showModal = true;
    }

    private async Task SaveTrack()
    {
        // Ensure UserId is set if it's a new track and was set in AddNewTrack
        if (modalTrack.Id == 0 && string.IsNullOrEmpty(modalTrack.UserId))
        {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var userId = authState.User?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
            if (!string.IsNullOrEmpty(userId))
            {
                modalTrack.UserId = userId;
            }
        }

        if (modalTrack.Id == 0)
            await LearningTrackRepo.AddAsync(modalTrack);
        else
            await LearningTrackRepo.UpdateAsync(modalTrack);

        await ToastService.ShowToast("Track saved!", ToastLevel.Success);
        showModal = false;
        await LoadTracksFromRepo();
        StateHasChanged();
    }

    private void CloseModal()
    {
        showModal = false;
    }

    private async Task DeleteTrack(LearningTrack track)
    {
        try
        {
            await LearningTrackRepo.DeleteAsync(track.Id);
            await ToastService.ShowToast($"Track deleted: {track.Name}", ToastLevel.Success);
            // If the deleted track was the selected one, clear the selection
            if (selectedTrack == track)
            {
                selectedTrack = null;
                await OnLearningTrackSelected.InvokeAsync(null); // Notify parent if it cares about deselection
            }
            await LoadTracksFromRepo();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await ToastService.ShowToast($"Failed to delete track: {ex.Message}", ToastLevel.Error);
        }
    }
}